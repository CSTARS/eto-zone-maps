* ETo modifications

I have been having a long term back and forth with DWR on the best possible
method to include the cimis lt_15day data into the ETo Zone Maps.  We have
had multiple discussions on what the best method to do this would be.  Bekele
has wanted to modify the ETo zone map values to include the ETo Station data. I
have been resistant to that, since I only thought it confused matters.

Recently, I've had a bit of an epiphany about how we might go about this.  Since
we have the ETo parameters for both the Stations, and for the underlying raster
data, what we can do is to calculate what the ratio is between the different
parameters that make up the ETo simplification.  That is, we can create ratios
between the p0, p0 and H0 values. We can then use a spline fit to spread these
ratios across all of CA. Using these updated values, we can then create a new
zone map, that uses these values to calculate the best fit for each zone.  From
that, we can then look at where the zones differ, and use that as an estimation
of where we are unclear about the estimations of ET from our station
perturbations.

I think this is a superior method for a number of reasons.  First, we can
compare to maps to really see where the differences of the two methods are, and
Secondly, if we really want to estimate something like the total change in ETo
from the two methods, then we can use these estimates way more reliably.  (In
fact, we can just look at the p0 maps :)

We used to station estimates, the station_* tables and the lt_15day_* tables.
The lt_15day tables from the [[file:NOTES.org::*DWR%20Long%20term%20average][DWR Long term average]] data, and their
calcutations.  This is the data that we want to use.  The FFT values for the
stations is compare.lt_15day_fft, as defined in [[file:NOTES.org::*Station%20FFT][Station FFT]].

 #+header: :engine postgresql
 #+header: :database eto_zones
 #+BEGIN_SRC sql :results raw
 select fft.require_fft();
select * from compare.lt_15day_fft
limit 4;
 #+END_SRC

 #+RESULTS:
 station_id	p0	p1	h1	p2	h2
 2	4.377	3.368	270	-0.098	-17.585
 5	3.907	2.918	269	-0.118	-36.357
 6	3.975	2.992	272	-0.033	-33.617
 7	3.846	3.041	269	-0.061	-19.140

Super! Now we want to compare this data with the raster long term averages.  The
raster long term average data exists in the file, fft.raster_15avg_ed.  There is
one for every pixel, we just need to join that to the station data.  We created
a table for the station's associated pid from compare.station_xy that combines
the station_info w/ the cimis boundaries, so we can just use that.  Note,
however, the lt_* data reports some stations considerably far from the
station_info data.  We are assuming the station info is correct.

 #+header: :engine postgresql
 #+header: :database eto_zones
 #+BEGIN_SRC sql
 with a as (
 select *,
 st_distance(st_transform(st_setsrid(st_makepoint(longitude,latitude),4269),3310),
             st_setsrid(st_makepoint(st_x,st_y),3310)) as diff
 from compare.station_xy s
 join compare.lt_15day_ll lt using (station_id)
)
select station_id,longitude,latitude,diff::integer
from a
where diff > 500
order by diff desc;
#+END_SRC

#+RESULTS:
| station_id | longitude | latitude |  diff |
|------------+-----------+----------+-------|
|        135 |  -114.666 |   33.557 | 15431 |
|        196 |  -122.144 |   38.685 | 11337 |
|         88 |  -119.605 |   34.932 |  6388 |
|         84 |  -121.311 |   39.271 |  2088 |
|        152 |  -118.994 |   34.232 |  1407 |
|        114 |   -121.29 |   36.359 |  1305 |
|        170 |   -122.02 |   38.004 |  1264 |
|        194 |  -120.851 |   37.719 |   911 |
|        136 |  -116.154 |   33.516 |   868 |
|        175 |  -114.726 |   33.389 |   863 |
|         74 |  -116.973 |    33.09 |   758 |
|         56 |  -120.761 |   37.093 |   752 |
|         79 |  -122.421 |   38.549 |   698 |
|         62 |  -117.222 |    33.49 |   691 |
|         77 |   -122.41 |   38.434 |   614 |
|         90 |  -120.479 |   41.433 |   589 |
|        200 |  -116.258 |   33.746 |   553 |

Here's the raster Long_term ET parameters

#+header: :engine postgresql
#+header: :database eto_zones
#+BEGIN_SRC sql
 create view compare.r_ymd15_fft as
 select station_id,
 e[1] as p0,e[2] as p1,d[2] as h1,
 e[3] as p2,d[3] as h2
from compare.station_xy
join fft.raster_15avg_ed
using (pid);
#+END_SRC

#+RESULTS:
| CREATE VIEW |
|-------------|


okay we need the same data for the data from the Spatial CIMIS.  Well it
turns out we already have this data (at least the raw eto data) in the file
compare.ymd15.  This reads in data that was exported from the spatial cimis
data.  It's the station and raster data for all the points in time that stations
reported data for our calculations.

So we just need to calculate the station fft data (which we already have
somewhere, but we can calculate here.  Similar to the lt_15day_fft, we'll
calculate the compare.raster_station_fft as :

 #+header: :engine postgresql
 #+header: :database eto_zones
 #+BEGIN_SRC sql :results raw
select fft.require_fft();
create view compare.s_ymd15_fft as
with v as (
 select station_id,
 extract (month from ymd15) as m,
 extract (day from ymd15) as d,
 count(*) as count,
 avg(r_eto) as r_eto,
 avg(s_eto) as s_eto
 from compare.ymd15
 group by station_id,m,d
),
e as (
 select station_id,(avg(count))::decimal(4,1) as window_count,
 fft(array_agg(r_eto order by case when (m<10) then m+12 else m end)) as r_eto,
 fft(array_agg(s_eto order by case when (m<10) then m+12 else m end)) as s_eto
 from v
 group by station_id
)
select station_id,window_count,
(r_eto).e[1]::decimal(6,3) as r_p0,
(r_eto).e[2]::decimal(6,3) as r_p1,
(r_eto).d[2]::integer as r_h1,
--(r_eto).e[3]::decimal(6,3) as r_p2,
--(r_eto).d[3]::decimal(6,3) as r_h2,
(s_eto).e[1]::decimal(6,3) as s_p0,
(s_eto).e[2]::decimal(6,3) as s_p1,
(s_eto).d[2]::integer as s_h1
--(s_eto).e[3]::decimal(6,3) as s_p2,
--(s_eto).d[3]::decimal(6,3) as s_h2
from e;
#+END_SRC

 #+RESULTS:
 require_fft


Now, we need to calculate the ratios.  For the s_eto data, we'll use the raster
data calculated only for the same time frame.  For the long_term rasters, we'll
use the complete raster record.

#+header: :engine postgresql
#+header: :database eto_zones
#+BEGIN_SRC sql :results raw
create or replace view compare.lt_s_ratio as
with s as (
select
station_id,window_count as station_overlap_yrs,
r_p0 as s_r_p0,
r_p1 as s_r_p1,
s_p0 as s_p0,
s_p1 as s_p1,
(s_p0/r_p0)::decimal(6,3) as s_p0_ratio,
(s_p1/r_p1)::decimal(6,3) as s_p1_ratio
from compare.s_ymd15_fft
where window_count > 5
),
lt as (
select station_id,
r.p0::decimal(6,3) as r_p0,
r.p1::decimal(6,3) as r_p1,
lt.p0 as lt_p0,
lt.p1 as lt_p1,
(lt.p0/r.p0)::decimal(6,3) as lt_p0_ratio,
(lt.p1/r.p1)::decimal(6,3) as lt_p1_ratio
from compare.r_ymd15_fft r join
compare.lt_15day_fft lt using (station_id)
)
select station_id,
r_p0,r_p1,
lt_p0,lt_p1,
lt_p0_ratio,
lt_p1_ratio,
s.station_overlap_yrs,
s_r_p0,s_r_p1,
s_p0,s_p1,
s_p0_ratio,
s_p1_ratio
from s full outer join lt using (station_id)
#+END_SRC

#+RESULTS:

** Grass Processing

In order to use our spline fitting routine from grass, we need to export the
data into a CSV file for import into grass.

#+header: :engine postgresql
#+header: :database eto_zones
#+BEGIN_SRC sql :results raw
select fft.require_fft();
create temp view tmp_compare as
select station_id,station_overlap_yrs,
s_p0,s_r_p0,lt_p0,r_p0,lt_p0_ratio,s_p0_ratio
from compare.lt_s_ratio
order by station_id;

create temp view tmp_station_compare as
select
station_id,st_x,st_y,i.elevation*0.3048 as z,
station_overlap_yrs,
s_p0,s_r_p0,lt_p0,r_p0,lt_p0_ratio,s_p0_ratio
from tmp_compare join compare.station_info i using (station_id)
join compare.station_xy using (station_id);
\COPY (select * from tmp_station_compare order by station_id) to ~/lt_s_ratio.csv with csv header
#+END_SRC

#+RESULTS:
require_fft

CREATE VIEW
CREATE VIEW
COPY 145


#+BEGIN_SRC bash
v.in.ascii --overwrite input=~/lt_s_ratio.csv x=2 y=3 z=4 output=ratio format=point separator=,\
columns='station_id int,x double precision,y double,z double, \
station_overlap_yrs double,s_p0 double,s_r_p0 double,lt_p0 double,r_p0 double,lt_p0_ratio double,s_p0_ratio double'
#+END_SRC

When we get to the part where we try and create a spline fit through these
ratios, we have overshooting issues when points that are close together have a
large change in their ratio.  We've made special zscale,smooth, and tension
parameters for this fit.

#+BEGIN_SRC
#export GRASS_RENDER_IMMEDIATE=png;
export GRASS_RENDER_WIDTH=510;
export GRASS_RENDER_HEIGHT=560;
g.region -d b=-100 t=2500 tbres=1000;
for r in s lt; do
for s in 0 0.02; do
for z in 0.1 ; do
for t in 3 5 7 10; do
 p0=${r}_s${s}_z${z}_t${t}_p0;
 v.vol.rst --overwrite input=ratio wcolumn=${r}_p0_ratio \
  cross_input=Z@2km maskmap=state@2km \
 tension=${t} zscale=${z} smooth=${s}  cross_output=${p0} \
 where="${r}_p0_ratio is not null and station_overlap_yrs > 4";
 r.mapcalc --overwrite expression="r${p0}=if($p0>0.8,$p0,1)";
 r.colors map=r${p0} color=gyr;
 export GRASS_RENDER_FILE="${p0}.png";
 d.mon --overwrite start=png;
 d.erase;
 d.rast r${p0};
 d.legend title="${p0}"
 raster=r${p0};
 d.mon stop=png;
done;done;done;done 2>&1 | tee vol.rst.txt
#g.region -d
#+END_SRC


with r as (select *,st_setsrid(st_makepoint(st_x,st_y),3310) as pt from station_xy join lt_s_ratio using (station_id) where lt_p0
_ratio is not null and station_overlap_yrs>2) select r1.station_id,r2.station_id,r1.key,r2.key,r1.lt_p0_ratio,r2.lt_p0_ratio,abs((r1.lt_p0_ra
tio-r2.lt_p0_ratio)/st_distance(r1.pt,r2.pt)) as d from r r1 join r r2 on
(r1.station_id < r2.station_id ) order by d desc;
